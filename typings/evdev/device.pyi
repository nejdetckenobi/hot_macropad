"""
This type stub file was generated by pyright.
"""

import contextlib
from evdev.eventio_async import EventIO

_AbsInfo = ...
_KbdInfo = ...
_DeviceInfo = ...
class AbsInfo(_AbsInfo):
    '''Absolute axis information.

    A ``namedtuple`` used for storing absolute axis information -
    corresponds to the ``input_absinfo`` struct:

    Attributes
    ---------
    value
      Latest reported value for the axis.

    min
      Specifies minimum value for the axis.

    max
      Specifies maximum value for the axis.

    fuzz
      Specifies fuzz value that is used to filter noise from the
      event stream.

    flat
      Values that are within this value will be discarded by joydev
      interface and reported as 0 instead.

    resolution
      Specifies resolution for the values reported for the axis.
      Resolution for main axes (``ABS_X, ABS_Y, ABS_Z``) is reported
      in units per millimeter (units/mm), resolution for rotational
      axes (``ABS_RX, ABS_RY, ABS_RZ``) is reported in units per
      radian.

    Note
    ----
    The input core does not clamp reported values to the ``[minimum,
    maximum]`` limits, such task is left to userspace.

    '''
    def __str__(self) -> str:
        ...
    


class KbdInfo(_KbdInfo):
    '''Keyboard repeat rate.

    Attributes
    ----------
    repeat
      Keyboard repeat rate in characters per second.

    delay
      Amount of time that a key must be depressed before it will start
      to repeat (in milliseconds).
    '''
    def __str__(self) -> str:
        ...
    


class DeviceInfo(_DeviceInfo):
    '''
    Attributes
    ----------
    bustype
    vendor
    product
    version
    '''
    def __str__(self) -> str:
        ...
    


class InputDevice(EventIO):
    '''
    A linux input device from which input events can be read.
    '''
    __slots__ = ...
    def __init__(self, dev) -> None:
        '''
        Arguments
        ---------
        dev : str|bytes|PathLike
          Path to input device
        '''
        ...
    
    def __del__(self): # -> None:
        ...
    
    def capabilities(self, verbose=..., absinfo=...): # -> dict[tuple[Any, Any], list[Any]] | dict[Any, Any]:
        '''
        Return the event types that this device supports as a mapping of
        supported event types to lists of handled event codes.

        Example
        --------
        >>> device.capabilities()
        { 1: [272, 273, 274],
          2: [0, 1, 6, 8] }

        If ``verbose`` is ``True``, event codes and types will be resolved
        to their names.

        ::

          { ('EV_KEY', 1): [('BTN_MOUSE', 272),
                            ('BTN_RIGHT', 273),
                            ('BTN_MIDDLE', 273)],
            ('EV_REL', 2): [('REL_X', 0),
                            ('REL_Y', 1),
                            ('REL_HWHEEL', 6),
                            ('REL_WHEEL', 8)] }

        Unknown codes or types will be resolved to ``'?'``.

        If ``absinfo`` is ``True``, the list of capabilities will also
        include absolute axis information in the form of
        :class:`AbsInfo` instances::

          { 3: [ (0, AbsInfo(min=0, max=255, fuzz=0, flat=0)),
                 (1, AbsInfo(min=0, max=255, fuzz=0, flat=0)) ]}

        Combined with ``verbose`` the above becomes::

          { ('EV_ABS', 3): [ (('ABS_X', 0), AbsInfo(min=0, max=255, fuzz=0, flat=0)),
                             (('ABS_Y', 1), AbsInfo(min=0, max=255, fuzz=0, flat=0)) ]}

        '''
        ...
    
    def input_props(self, verbose=...): # -> list[Any]:
        '''
        Get device properties and quirks.

        Example
        -------
        >>> device.input_props()
        [0, 5]

        If ``verbose`` is ``True``, input properties are resolved to their
        names. Unknown codes are resolved to ``'?'``::

        [('INPUT_PROP_POINTER', 0), ('INPUT_PROP_POINTING_STICK', 5)]

        '''
        ...
    
    def leds(self, verbose=...): # -> list[Any]:
        '''
        Return currently set LED keys.

        Example
        -------
        >>> device.leds()
        [0, 1, 8, 9]

        If ``verbose`` is ``True``, event codes are resolved to their
        names. Unknown codes are resolved to ``'?'``::

        [('LED_NUML', 0), ('LED_CAPSL', 1), ('LED_MISC', 8), ('LED_MAIL', 9)]

        '''
        ...
    
    def set_led(self, led_num, value): # -> None:
        '''
        Set the state of the selected LED.

        Example
        -------
        >>> device.set_led(ecodes.LED_NUML, 1)
        '''
        ...
    
    def __eq__(self, other) -> bool:
        '''
        Two devices are equal if their :data:`info` attributes are equal.
        '''
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __fspath__(self): # -> Any:
        ...
    
    def close(self): # -> None:
        ...
    
    def grab(self): # -> None:
        '''
        Grab input device using ``EVIOCGRAB`` - other applications will
        be unable to receive events until the device is released. Only
        one process can hold a ``EVIOCGRAB`` on a device.

        Warning
        -------
        Grabbing an already grabbed device will raise an ``IOError``.
        '''
        ...
    
    def ungrab(self): # -> None:
        '''
        Release device if it has been already grabbed (uses `EVIOCGRAB`).

        Warning
        -------
        Releasing an already released device will raise an
        ``IOError('Invalid argument')``.
        '''
        ...
    
    @contextlib.contextmanager
    def grab_context(self): # -> Generator[None, Any, None]:
        '''
        A context manager for the duration of which only the current
        process will be able to receive events from the device.
        '''
        ...
    
    def upload_effect(self, effect):
        '''
        Upload a force feedback effect to a force feedback device.
        '''
        ...
    
    def erase_effect(self, ff_id): # -> None:
        '''
        Erase a force effect from a force feedback device. This also
        stops the effect.
        '''
        ...
    
    @property
    def repeat(self): # -> KbdInfo:
        '''
        Get or set the keyboard repeat rate (in characters per
        minute) and delay (in milliseconds).
        '''
        ...
    
    @repeat.setter
    def repeat(self, value):
        ...
    
    def active_keys(self, verbose=...): # -> list[Any]:
        '''
        Return currently active keys.

        Example
        -------

        >>> device.active_keys()
        [1, 42]

        If ``verbose`` is ``True``, key codes are resolved to their
        verbose names. Unknown codes are resolved to ``'?'``. For
        example::

          [('KEY_ESC', 1), ('KEY_LEFTSHIFT', 42)]

        '''
        ...
    
    @property
    def fn(self): # -> Any:
        ...
    
    def absinfo(self, axis_num): # -> AbsInfo:
        '''
        Return current :class:`AbsInfo` for input device axis

        Arguments
        ---------
        axis_num : int
          EV_ABS keycode (example :attr:`ecodes.ABS_X`)

        Example
        -------
        >>> device.absinfo(ecodes.ABS_X)
        AbsInfo(value=1501, min=-32768, max=32767, fuzz=0, flat=128, resolution=0)
        '''
        ...
    
    def set_absinfo(self, axis_num, value=..., min=..., max=..., fuzz=..., flat=..., resolution=...): # -> None:
        '''
        Update :class:`AbsInfo` values. Only specified values will be overwritten.

        Arguments
        ---------
        axis_num : int
          EV_ABS keycode (example :attr:`ecodes.ABS_X`)

        Example
        -------
        >>> device.set_absinfo(ecodes.ABS_X, min=-2000, max=2000)

        You can also unpack AbsInfo tuple that will overwrite all values

        >>> device.set_absinfo(ecodes.ABS_Y, *AbsInfo(0, -2000, 2000, 0, 15, 0))
        '''
        ...
    


